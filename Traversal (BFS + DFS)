#include <iostream>
#include <unordered_map>
#include <list>
#include <queue>
using namespace std;
template <typename T>


class Graph{
    public:
    unordered_map<T,list<T>> adjList;

    void addEdge(T u,T v,bool direction){
      // direction = 0 -> undirected
      // direction = 1 -> directed

      adjList[u].push_back(v);

      if(direction == 0){
        adjList[v].push_back(u);

      }

    }

    void printAdjList(){
      cout<<"Printing Adjacency List: "<<endl;
      for(auto node:adjList){
        cout<<node.first<<"-> ";
        for(auto nbr:node.second){
          cout<<nbr<<",";
        }
        cout<<endl;
      }
    }


    void bfs(T src,unordered_map<T,bool> &vis){
      queue<T> q;
      q.push(src);
      vis[src] = true;

      while(!q.empty()){
        auto fNode = q.front();
        q.pop();
        // process Front node
        cout<<fNode<<", ";
        // insert nbr of Front Node, if not visited
        for(auto nbr:adjList[fNode]){
          if(!vis[nbr]){
            q.push(nbr);
            vis[nbr] = true;
          }
        } 
      }
    }

    void dfs(T src,unordered_map<int,bool> &vis){
      cout<<src<<", ";
      vis[src] = true;

      for(auto nbr:adjList[src]){
        if(!vis[nbr]){
          dfs(nbr,vis);
        }
      }
    }
};

int main() {
  int n = 8; //number of nodes
  Graph<int> g;
  g.addEdge(0,1,0);
  g.addEdge(1,2,0);
  g.addEdge(1,3,0);
  g.addEdge(3,5,0);
  g.addEdge(3,7,0);
  g.addEdge(7,6,0);
  g.addEdge(7,4,0);
  
  g.printAdjList();

  unordered_map<int,bool> vis;

  cout<< "BFS Traversal :"<<endl; 
  for(int i=0;i<n;i++){
    if(!vis[i]){
      g.bfs(i,vis);
    }
  }
  cout<<endl;


  unordered_map<int,bool> vis2;

  cout<< "DFS Traversal :"<<endl; 
  for(int i=0;i<n;i++){
    if(!vis2[i]){
      g.dfs(i,vis2);
    }
  }



  return 0;

}
