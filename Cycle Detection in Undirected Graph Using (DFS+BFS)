#include <iostream>
#include <unordered_map>
#include <list>
#include <queue>
using namespace std;


class Graph{
    public:
    unordered_map<int,list<int>> adj;

    void addEdge(int u,int v,bool direction){
      // 0->undirected
      // 1-> dirrected

      adj[u].push_back(v);
      if(direction==0){
        adj[v].push_back(u);
      }
    }

    void printAdjList(){
      for(auto node:adj){
        cout<<node.first<<"->";
        for(auto nbr:node.second){
          cout<<nbr<<", ";
        }
        cout<<endl;
      }
    }


    bool cycleDetectionUsingBFS_undirected(int src,unordered_map<int,bool> &vis){
      unordered_map<int,int> parent;
      queue<int> q;
      q.push(src);
      vis[src] = true;
      parent[src] = -1;

      while(!q.empty()){
        int fNode = q.front();
        q.pop();

        for(auto nbr:adj[fNode]){
          if(!vis[nbr]){
            q.push(nbr);
            vis[nbr] = true;
            parent[nbr] = fNode;
          }
          else{
            if(nbr != parent[fNode]){
              return true;
            }
          }
        }
      }
      return false;
    }


    bool cycleDetectionUsingDFS_undirected(int src,unordered_map<int,bool> &vis,int parent){
      vis[src] = true;
      for(auto nbr:adj[src]){
        if(!vis[nbr]){
          bool ans = cycleDetectionUsingDFS_undirected(nbr,vis,src);
          if(ans == true) return true;
        }
        else{
          // not visited
          if(nbr != parent){
            return true;
          }
        }
      }
      return false;
    }
};
int main() {
  Graph g;
  int n = 5;
  g.addEdge(0,1,0);
  g.addEdge(1,3,0);
  g.addEdge(0,2,0);
  g.addEdge(2,4,0);

  unordered_map<int,bool> visBfs;
  bool ansBfs = false;
  for(int i=0;i<n;i++){
    if(!visBfs[i]){
      ansBfs = g.cycleDetectionUsingBFS_undirected(i,visBfs);
      if(ansBfs == true) break;
    }
  }

  cout<<"For Using BFS Graph 1:";
  if(ansBfs){
    cout<<"Cycle is Present "<<endl;
  }
  else{
    cout<<"Cycle Absent "<<endl;
  }
  


  Graph g1;
  int m = 7;
  g1.addEdge(0,1,0);
  g1.addEdge(1,2,0);
  g1.addEdge(1,3,0);
  g1.addEdge(3,4,0);
  g1.addEdge(3,5,0);
  g1.addEdge(5,6,0);
  g1.addEdge(4,6,0);

  unordered_map<int,bool> visDfs;
  bool ansDfs = false;
  for(int i=0;i<m;i++){
    if(!visDfs[i]){
      ansDfs = g1.cycleDetectionUsingDFS_undirected(i,visDfs,-1);
      if(ansDfs == true) break;
    }
  }
  cout<<"For Using DFS Graph 2:";
  if(ansDfs){
    cout<<"Cycle is Present "<<endl;
  }
  else{
    cout<<"Cycle Absent "<<endl;
  }

  return 0;
}
