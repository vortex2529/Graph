#include <iostream>
#include <unordered_map>
#include <list>
#include <queue>
using namespace std;


class Graph{
    public:
    unordered_map<int,list<int>> adj;

    void addEdge(int u,int v,bool direction){
      // 0->undirected
      // 1-> dirrected

      adj[u].push_back(v);
      if(direction==0){
        adj[v].push_back(u);
      }
    }

    void printAdjList(){
      for(auto node:adj){
        cout<<node.first<<"->";
        for(auto nbr:node.second){
          cout<<nbr<<", ";
        }
        cout<<endl;
      }
    }


    


    bool cycleDetectionUsingDFS_directed(int src,unordered_map<int,bool> &vis,unordered_map<int,bool> &dfsVis){
      vis[src] = true;
      dfsVis[src] = true;
      for(auto nbr:adj[src]){
        if(!vis[nbr]){
          bool ans = cycleDetectionUsingDFS_directed(nbr,vis,dfsVis);
          if(ans == true) return true;
        }
        else{
          // not visited
          if(dfsVis[nbr]){
            return true;
          }
        }
      }
      dfsVis[src]=false;
      return false;
    }
};
int main() {
  
  


  Graph g1;
  int m = 7;
  g1.addEdge(0,1,0);
  g1.addEdge(1,2,0);
  g1.addEdge(1,3,0);
  g1.addEdge(3,4,0);
  g1.addEdge(3,5,0);
  g1.addEdge(5,6,0);
  g1.addEdge(4,6,0);

  unordered_map<int,bool> vis;
  unordered_map<int,bool> dfsVis;

  bool ansDfs = false;
  for(int i=0;i<m;i++){
    if(!vis[i]){
      ansDfs = g1.cycleDetectionUsingDFS_directed(i,vis,dfsVis);
      if(ansDfs == true) break;
    }
  }
  cout<<"For Using DFS Graph 2:";
  if(ansDfs){
    cout<<"Cycle is Present "<<endl;
  }
  else{
    cout<<"Cycle Absent "<<endl;
  }

  return 0;
}
